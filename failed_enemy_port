
std::vector<std::vector<bool>> Logic::enemyCollisionSide() {

    //std::vector<std::vector<bool>> collisionSide(enemies.enemies.size(), std::vector<bool>(4, false));


    for (int i = 0; i < enemies.enemies.size(); i++) {

        for (auto& element : platformBounds) {

            if (enemies.enemies[i].getGlobalBounds().intersects(element)) {
                
                float playerTop = enemies.enemies[i].getPosition().y;
                float playerBottom = enemies.enemies[i].getPosition().y + enemies.enemies[i].getSize().y;
                float playerLeft = enemies.enemies[i].getPosition().x;
                float playerRight = enemies.enemies[i].getPosition().x + enemies.enemies[i].getSize().x;

                const float shapeTop = element.top;
                const float shapeBottom = element.top + element.height;
                const float shapeLeft = element.left;
                const float shapeRight = element.left + element.width;

                float topOverlap = playerBottom - shapeTop;
                float bottomOverlap = shapeBottom - playerTop;
                float leftOverlap = playerRight - shapeLeft;
                float rightOverlap = shapeRight - playerLeft;

                if (std::min({ topOverlap, bottomOverlap, leftOverlap, rightOverlap }) > 0.f) {
                    if (topOverlap < bottomOverlap && topOverlap < leftOverlap && topOverlap < rightOverlap) {
                        enemies.enemies[i].setPosition(enemies.enemies[i].getPosition().x, shapeTop - enemies.enemies[i].getSize().y);
                        enemies.enemiesVelocities[i].y = 0;
                        enemies.collisionSide[i][2] = true;
                        /*enemies.collisionSide[i][0] = false;
                        enemies.collisionSide[i][1] = false;
                        enemies.collisionSide[i][3] = false;*/

                        
                        
                        //std::cout << "Enemy: " << i << " " << enemies.collisionSide[i][2] << "\n";

                        std::cout << i << " esta tocando el piso" << std::endl;
                        //enemies.enemiesVelocities[i].y = enemies.enemyJumpSpeed;
                        //enemies.enemies[i].move(enemies.enemiesVelocities[i]);

                    } else if (bottomOverlap < topOverlap && bottomOverlap < leftOverlap && bottomOverlap < rightOverlap) {
                        enemies.enemies[i].setPosition(enemies.enemies[i].getPosition().x, shapeBottom);
                        enemies.enemiesVelocities[i].y = 0;
                        enemies.collisionSide[i][0] = true; 
                        enemies.collisionSide[i][1] = false;
                        enemies.collisionSide[i][2] = false;
                        enemies.collisionSide[i][3] = false;

                        std::cout << "tocando el techo" << std::endl;

                    } else if (leftOverlap < topOverlap && leftOverlap < bottomOverlap && leftOverlap < rightOverlap) {
                        enemies.enemies[i].setPosition(shapeLeft - enemies.enemies[i].getSize().x, enemies.enemies[i].getPosition().y);
                        //shapeVelocities[i].x = 0;
                        enemies.collisionSide[i][3] = true;
                        enemies.collisionSide[i][0] = false;
                        enemies.collisionSide[i][1] = false;
                        enemies.collisionSide[i][2] = false;

                        std::cout << "tocando la derecha" << std::endl;
                        enemies.enemiesVelocities[i].y = enemies.enemyJumpSpeed;
                        enemies.enemies[i].move(enemies.enemiesVelocities[i]);

                    } else if (rightOverlap < topOverlap && rightOverlap < bottomOverlap && rightOverlap < leftOverlap) {
                        enemies.enemies[i].setPosition(shapeRight, enemies.enemies[i].getPosition().y);
                        //shapeVelocities[i].x = 0;
                        enemies.collisionSide[i][1] = true;
                        enemies.collisionSide[i][0] = false;
                        enemies.collisionSide[i][2] = false;
                        enemies.collisionSide[i][3] = false;
                        std::cout << "tocando la izquierda" << std::endl;

                    }
                }
            }

        }

        locatePlayerWithIndex(i);
        updateEnemyVelocity();
    }

    return enemies.collisionSide;
}


void Logic::updateEnemyVelocity() {
    for (int i = 0; i < enemies.enemies.size(); i++) {
        if (enemies.enemies[i].getPosition().x > 0) {
            
            enemyGravityV2(i);
            enemies.enemiesVelocities[i].x *= 0.75;
            enemies.enemies[i].move(enemies.enemiesVelocities[i]);
        }
    }
}


void Logic::enemyGravity() {
    const float Gravity = 0.7f;
    
    for (int i = 0; i < enemies.enemies.size(); i++) {
        enemies.enemiesVelocities[i].y += Gravity;
    }

}


void Logic::enemyGravityV2(int index) {
    const float Gravity = 0.7f;
    enemies.enemiesVelocities[index].y += Gravity;
    //enemies.enemies[index].move(enemies.enemiesVelocities[index]);
}


void Logic::locatePlayer() {
    const float enemyRange = 4000.0f;

    for (size_t i = 0; i < enemies.enemies.size(); i++) {
        sf::Vector2f enemyToPlayer = player.playerCharacter[0].getPosition() - enemies.enemies[i].getPosition();
        float distance = std::hypot(enemyToPlayer.x, enemyToPlayer.y);
        if (distance <= enemyRange && std::abs(enemyToPlayer.y) <= enemyRange) {
            enemyToPlayer /= distance;

            // Update only the X component of the enemy velocity based on the player's position
            enemies.enemiesVelocities[i].x = enemyToPlayer.x * enemies.enemyTopSpeed;
        }
    }
}




void Logic::locatePlayerWithIndex(int index) {

    const float enemyRange = 4000.0f;
    sf::Vector2f enemyToPlayer = player.playerCharacter[0].getPosition() - enemies.enemies[index].getPosition();
        float distance = std::hypot(enemyToPlayer.x, enemyToPlayer.y);
        if (distance <= enemyRange && std::abs(enemyToPlayer.y) <= enemyRange) {
            enemyToPlayer /= distance;

            // Update only the X component of the enemy velocity based on the player's position
            enemies.enemiesVelocities[index].x = enemyToPlayer.x * enemies.enemyTopSpeed;
        }
}


void Logic::enemiesRespawner() {
    static sf::Clock timer;
    static sf::Clock decreaseTimer;
    sf::Time elapsed = timer.getElapsedTime();
    sf::Time decreaseElapsed = decreaseTimer.getElapsedTime();
    static int respawn;
    static float respawn_time = 5.0f;
    static bool spawnRight = true;
    /*
    if (respawn == 99) {
        respawn = 0; 
    }
    */
    if (respawn != enemies.enemies.size()) {

        if (elapsed.asSeconds() > respawn_time) { 
            // Check if player's position is less than 700
            /*if (player.playerCharacter[0].getPosition().x < 1200) {
                spawnRight = true; // Always spawn from the right
            }*/
            if (player.playerCharacter[0].getPosition().x > 11500) {
                spawnRight = false; // Always spawn from the left
            }

            // Calculate the position offset based on the spawn direction
            float offsetX = spawnRight ? 100.0f : -100.0f;

            float offsetY = player.playerCharacter[0].getPosition().y - enemies.enemies[0].getSize().y;


        
            offsetX += randNum(0.f, 150.f);
            enemies.enemies[respawn].setPosition(player.playerCharacter[0].getPosition().x + offsetX, 100);
            respawn++;
            offsetX += randNum(0.f, 150.f);
            enemies.enemies[respawn].setPosition(player.playerCharacter[0].getPosition().x + offsetX, 100);
            respawn++;
            offsetX += randNum(0.f, 150.f);
            enemies.enemies[respawn].setPosition(player.playerCharacter[0].getPosition().x + offsetX, 100);
            respawn++;
            timer.restart();
        

            // Toggle the spawn direction for the next enemy
            spawnRight = !spawnRight;
        }

        if (decreaseElapsed.asSeconds() > 15.0f && respawn_time > 0.5) {
            respawn_time -= 0.50f;
            std::cout << respawn_time << "\n";
            decreaseTimer.restart();
        }
    }
}



void Logic::enemyAI() {

    
    enemiesRespawner();

    //enemyGravity();
    enemyCollisionSide();
    //updateEnemyVelocity();

}








for (size_t i = 0; i < enemies.enemies.size(); i++) {
    const auto& val = enemies.collision[i];
    auto& enemy = enemies.enemies[i];
    if (val[0]) {
        std::cout << "Enemy: " << i << " tocando el techo " << val[0] << std::endl;
    // Handle collision with top of the platform
    }
    if (val[1]) {

        std::cout << "Enemy: " << i << " tocando la izquierda " << val[1] << std::endl;
        // Handle collision with right side of the platform
        //enemies.enemiesVelocities[i].y = enemies.enemyJumpSpeed;
        //std::cout << "Enemy Number: " << i << " enemy Velocity: " << enemies.enemies[i].getPosition().y << "\n";

    }
    if (val[2]/* && !val[1] && !val[3]*/) {
        //std::cout << "Enemy: " << i << " tocando el piso " << val[2] << std::endl;
        
        // Calculate vector from enemy to player
        sf::Vector2f enemyToPlayer = player.playerCharacter[0].getPosition() - enemies.enemies[i].getPosition();

        // Calculate distance between enemy and player
        float distance = std::sqrt(enemyToPlayer.x * enemyToPlayer.x + enemyToPlayer.y * enemyToPlayer.y);
        
        // Check if the enemy is within range of the player
        if (distance <= enemyRange) {
            // Normalize vector
            enemyToPlayer /= distance;

            // Set shape velocity proportional to enemyToPlayer
            enemies.enemiesVelocities[i] = enemyToPlayer * enemies.enemyTopSpeed;
        }
        /*if (enemies.enemiesHealth[i] <= 50) {
            enemies.enemiesVelocities[i].y = enemies.enemyJumpSpeed;
        }
        if (enemies.enemiesHealth[i] <= 25) {
            enemies.enemiesVelocities[i].x = enemyToPlayer.x * enemies.enemyAlmostDeadSpeed;
        }*/

    }
    if (val[3]) {
        std::cout << "Enemy: " << i << " tocando la derecha " << val[3] << std::endl;

        // Handle collision with left side of the platform
        //enemies.enemiesVelocities[i].y = enemies.enemyJumpSpeed; 
    }
}